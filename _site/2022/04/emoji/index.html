<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="You might be think that there is no difference between classic prototype inheritance and inheritance based on classes. But that's not true actually."><link rel="stylesheet" href="/styles/common.css"><link rel="stylesheet" href="/styles/main.css"><title>Emoji in JS strings</title></head><body><header><h1><a href="/">üè°</a></h1></header><main><h1>Emoji in JS strings</h1><p>Let's consider JavaScript string, which consist only one emoji and we want to take length from it:</p><pre><code class="hljs language-js"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;üòÖ&quot;</span>.<span class="property">length</span>);
</code></pre><p>What do you think, what is the value of this property? It's displayed as the one symbol, but you will be surprised by the actual result. It's 2.</p><p>Emoji from a platform to a platform, from an app to an app can has dirrefent representation: like a text or like an image. Image is obvious format.</p><p>But what about text? So, emoji, which represented as a text is unicode symbol. Unicode is a standard which defines a lot of symbols from different languages. All of this symbols have their order numbers in defined range: from <code>0x0000</code> to <code>0x10FFFF</code>. This order numbers called code points. So, in JavaScript strings represent as sequence of 16 bit code units. So, it's looks like UCS-2, but in the text of specifications only UTF-8 is mentioned. The main difference between them that UCS-2 cannot represent symbols outside of BMP range (<code>0x0000-0xFFFF</code>). It's happens because UCS-2 defines one symbol as 2 byte charachter, thus maximum value that this character might represent is 65535 (<code>0xFFFF</code>). UTF-16 is variable-length encoding, which means that symbols in this encoding might be as one 2 byte block or two of them. For the BMP range it represents symbols the same as UCS-2: we just take codepoint from Unicode standard and put this number as is.</p><p>For example, cyrillic capital short i letter (–π) with codepoint 1049 will be presented in the memory as binary representation of this number:</p><pre><code class="hljs language-js"><span class="number">0b00000100_00011001</span>
</code></pre><p>Okay, but what about symbols that lay outside of BMP? The most of Emoji, i.e., exists in the range <code>0x1F000-0x1FAFF</code>. Obviously, all symbols from this range cannot be represented as one 2 byte character: the lower one 0x1F000 in binary representation will has the following form:</p><pre><code class="hljs language-js"><span class="number">0b11111000000000000</span>
</code></pre><p>It's number with length of 17 bits. How to deal with that additional bit? You cannot just take it and pad from start with leading zeros, at very least how you differ code point 1 from this part of code point with leading zeros and with 1 in the end? And here surrogaite pairs concept comes to help us with that problem.</p><p><a name="pairs"></a></p><h2><a href="#pairs">Surrogate pairs</a></h2><p>There are two special code points ranges, which reserved and cannot be used to represent any symbol in Unicode ‚Äî high surrogates <code>0xD800-0xDBFF</code> and low surrogates <code>0xDC00-0xDFFF</code>. So, consider that we want to encode in UTF-16 emoji symbol &quot;Smiling face with open mouth and cold sweat&quot; or, shortly üòÖ. This symbol has code point, according to Unicode standard 128517, or 0x01F605 in hexademical. As other code points from supplementary planes UTF-16 encode this symbol in special way with two 2 bytes units which called surrogate pair and formed by the following scheme:</p><ol><li>Substruct from code point <code>0x10000</code>. The result number should be represented in 20 bit value. So, for our emoji: <code>0x01F605 - 0x010000 = 0x00F605</code>. 20 bit representation of the result is following: <code>00001111011000000101</code>;</li><li>Delimet result to two 10 bit numbers: <code>0000111101</code> and <code>1000000101</code>;</li><li>Add high 10 bits <code>0xD800</code>. Result number always will be lay in the range of high surrogates. So, for our example:<br><code>0000111101 = 0x003D;</code><br><code>0x003D + 0xD800 = 0xD83D</code></li><li>Add low 10 bits to <code>0xDC00</code>. Result number always will be lay in the range of low suggorages. So, again, for our low ten bits of smile with cold sweat:<br><code>0000111101 = 0x0205;</code><br><code>0x0205 + 0xDC00 = 0xDE05</code></li></ol><p>Numbers from points 3. and 4. will form the first and the second code units, which will represent our emoji in UTF-16.</p><p>Thus, if we come back to JavaScript representation:</p><pre><code class="hljs language-js"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;üòÖ&quot;</span>.<span class="property">length</span>);
</code></pre><p>we has in this UTF-16 string two code units, that is why <code>length</code> value equals 2. If you will call method <code>charCodeAt</code> for the zero index you will receive already learnt by you surrogate code points:</p><pre><code class="hljs language-js"><span class="string">&quot;üòÖ&quot;</span>.<span class="title function_">charCodeAt</span>(<span class="number">0</span>).<span class="title function_">toString</span>(<span class="number">16</span>) <span class="comment">// &#x27;d83d&#x27;</span>
<span class="string">&quot;üòÖ&quot;</span>.<span class="title function_">charCodeAt</span>(<span class="number">1</span>).<span class="title function_">toString</span>(<span class="number">16</span>) <span class="comment">// &#x27;de05&#x27;</span>
</code></pre><p>To get code point of character you should call method of string <code>codePointAt</code>. This method will return code point value according to standard with keeping in mind surrogate pairs. It's important also to use correct index, because, as you already know that characters from supplementary planes will occupy more than one 16 bit values:</p><pre><code class="hljs language-js"><span class="string">&quot;üòÖ&quot;</span>.<span class="title function_">codePointAt</span>(<span class="number">0</span>) <span class="comment">// 128517</span>
</code></pre></main></body></html>