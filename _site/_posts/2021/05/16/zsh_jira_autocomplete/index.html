<h1>How to save time with ZSH completion system</h1><p>What you, as software engineer, usually do? Right! You create new git branches almost every day, even more than once per day. For example, one of my everyday patterns following:</p><ol><li>Look into the board in JIRA;</li><li>Open one of assigned to me ticket;</li><li>Move it to &quot;In progress&quot; status if it isn't yet;</li><li>Copy a key of the ticket;</li><li>Go to my command line;</li><li>Create a branch with the same name as the ticket's key, i.e. <code>feature/EXMPL-1234</code>.</li></ol><p>I have seen many times in different companies attempts of simplifying of that process: <a href="https://en.wikipedia.org/wiki/Bookmarklet" target="_blank">bookmarklets</a> that copy for you current tickets or browser extensions that complement JIRA tickets with copy button UI etc.</p><p>In one day I decided to return to my old idea to learn about <a href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html">ZSH completion system</a> and create completion that will do for me dirty job. And I've created it.</p><p>I use <a href="https://git-scm.com/book/en/v2/Git-Basics-Git-Aliases" target="_blank">Git aliases</a> in my Git setup and it works like a charm: you can create shorthands for all of operations that you do from console every day when you touch upon Git repositories, i.e.:</p><pre><code class="hljs language-sh">; ~/.gitconfig
; ...
[<span class="built_in">alias</span>]
  co = checkout
; ...
</code></pre><p>Using that config you can easily do some everyday routine:</p><pre><code class="hljs">~ git co my-awesome-branch
</code></pre><p>Great part of this functionality that autocompletion will works even with your aliases in ZSH. So, imagine that you would like to create alias for start point of your <a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank">Git flow</a>:</p><pre><code class="hljs language-sh">; ~/.gitconfig
; ...
[<span class="built_in">alias</span>]
  co = checkout
  ; Flow Branch
  fb = ! git checkout dev &amp;&amp; git pull &amp;&amp; git co -b
; ...
</code></pre><p>For our new alias <code>git fb</code> we've used alias that starts with exclamation mark because our command isn't just mapping from value to name of sub-command of git — it is list of commands.</p><p>So, imagine that you'd like to have completion for your name of tickets that will be based on your JIRA. It will be useful, right? I'm using <a href="https://www.zsh.org/" target="_blank">ZSH</a> as my shell and I will provide example of realization based on this shell.</p><p>ZSH can automatically load functions for you from folders that you specify in variable <code>fpath</code> inside your ZSH initialization scripts, i.e. in <code>~/.zshrc</code>:</p><pre><code class="hljs language-sh">fpath=(~/.zsh <span class="variable">$fpath</span>)
</code></pre><p>This instruction tells a shell to check scripts inside <code>~/.zsh/</code> folder when corresponding function was called. For example, let's create one of our functions:</p><pre><code class="hljs language-sh"><span class="comment"># ~/.zsh/foo</span>
<span class="built_in">echo</span> <span class="string">&quot;Initialized&quot;</span>

<span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() {
    <span class="built_in">echo</span> <span class="string">&quot;Called&quot;</span>
}

foo <span class="variable">$@</span>
</code></pre><p>, and also let's update our <code>~/.zshrc</code> script to automatically load function when we will call it:</p><pre><code class="hljs language-sh"><span class="comment"># ~/.zshrc</span>
<span class="comment"># ...</span>

fpath=(~/.zsh <span class="variable">$fpath</span>)
<span class="built_in">autoload</span> foo
</code></pre><p>Now, when you call <code>foo</code> for the first time, you will see message <code>Initialized</code>, then — message <code>Called</code>. After second time only a message <code>Called</code> will be printed. Thus, this system provide a way to initialize your scripts and automatically load definitions based on <code>fpath</code>.</p><p>But now, let's talk about completion system. In zsh it based on loading system that we discussed previously. Let's create simple completion that will be based on command and won't depends on position of parameter. For example, we want to create some custom completion for some existing binary, i.e. <code>ls</code>:</p><pre><code class="hljs language-sh"><span class="comment">#compdef ls</span>
<span class="comment">#</span>
<span class="comment"># ~/.zsh/_ls</span>

params=(One Two)

_describe <span class="string">&#x27;command&#x27;</span> params
</code></pre><p>The name of loadable function with underscore at start it is one of requirements of completion system. Other requirement is header of file: <code>#compdef ...</code>. This header describe command or other <a href="http://zsh.sourceforge.net/Doc/Release/Completion-System.html">options</a> for your autocomplete function. In this script we initialize array of strings that will be used as our completion items and the last line is one of the ZSH completion functions that provide <a href="https://github.com/zsh-users/zsh-completions/blob/master/zsh-completions-howto.org#writing-simple-completion-functions-using-_describe" target="_blank">the simplest way</a> to describe completion options.</p><p>Okay, it is possible to describe completion for executables and it's options. But what about our git aliases that we've created for git. Good news here that ZSH autocompletion scripts that come with Git, at least on OSX, provide to you way to describe completion for your Git aliases that will works as expected: you just need to create <code>$fpath/_git_&lt;your alias here&gt;</code> completion script and it will be invoked with your Git alias.</p><p>Using this way of describing completion of git alias I've created script that will do for me a task that I described in the beginning of article:</p><pre><code class="hljs language-sh"><span class="comment">#compdef git-fb</span>

<span class="built_in">local</span> email=<span class="variable">${EMAIL:-example@gmail.com}</span>
<span class="built_in">local</span> token=<span class="variable">${ATLASSIAN_TOKEN}</span>
<span class="built_in">local</span> jira_host=<span class="variable">${$JIRA_HOST:-example.atlassian.com}</span>

<span class="built_in">local</span> script=<span class="string">&#x27;
  let result = &quot;&quot;;
  process.stdin.on(&quot;data&quot;, (c) =&gt; result += c);
  process.stdin.on(&quot;end&quot;, () =&gt; {
    JSON.parse(result).issues.map((i) =&gt; {
      const short = i.fields.summary
        .replace(/\[\w+\]/g, &quot;&quot;)
        .replace(/\s/g, &quot;-&quot;)
        .toLowerCase()
        .match(/\w+(-\w+){1,2}/)[0]
      console.log(`feature/${i.key}:${i.fields.summary}`)
    });
  });
&#x27;</span>;

<span class="built_in">local</span> IFS=$<span class="string">&#x27;\n&#x27;</span>;

params=($(<span class="function"><span class="title">function</span></span> () {
  <span class="built_in">local</span> query=<span class="string">&quot;assignee=currentuser()%20AND%20status=%22In%20Progress%22&quot;</span>;
  <span class="built_in">local</span> params=<span class="string">&quot;jql=<span class="variable">${query}</span>&amp;fields=summary&quot;</span>

  curl -s -u <span class="string">&quot;<span class="variable">${email}</span>:<span class="variable">${token}</span>&quot;</span> \
  <span class="string">&quot;https://<span class="variable">${jira_host}</span>/rest/api/3/search\?<span class="variable">${params}</span>&quot;</span> \
    | node -e <span class="variable">$script</span>
}))

_describe <span class="string">&#x27;command&#x27;</span> params
</code></pre><p>This is script that goes to JIRA REST API and asks about all tickets that currently &quot;In progress&quot; and assigned to current user (it is specified by token and email variables) and format using simple Node.js script names of branches from key of tickets and, also, builds completion menu with all available variants for current argument prefix with the corresponding description of all filtered tickets.</p><p>Tricky part of this script is Node.js script that is being using to transform received from JIRA REST API endpoint JSON. It cannot be easily done with only UNIX text tools, i.e. sed, grep, awk etc. It will be depends on structure of JSON and will be to fragile. That's why I used Node.js in this part of script. Characteristic of Node.js is it's own callback-style way of describing asynchronous logic, thence, this script looks too complex.</p><p>I've rewrote it to Python and after that this part of logic becomes cleaner:</p><pre><code class="hljs language-sh"><span class="comment">#compdef git-fb</span>

<span class="built_in">local</span> email=<span class="variable">${EMAIL:-example@gmail.com}</span>
<span class="built_in">local</span> token=<span class="variable">${ATLASSIAN_TOKEN}</span>
<span class="built_in">local</span> jira_host=<span class="variable">${$JIRA_HOST:-example.atlassian.com}</span>

<span class="built_in">local</span> script=<span class="string">&#x27;
import sys,json,re

issues = json.load(sys.stdin)[&quot;issues&quot;]
pat = re.compile(&quot;\w+(-\w+){1,2}&quot;)

for issue in issues:
  short = pat.search(re.sub(r&quot;\s&quot;, &quot;-&quot;, re.sub(r&quot;\[\w+\]&quot;, &quot;&quot;, issue[&quot;fields&quot;][&quot;summary&quot;])).lower()).group(0)
  key = issue.get(&quot;key&quot;)
  summary = issue.get(&quot;fields&quot;).get(&quot;summary&quot;)
  print(f&quot;feature/{key}-{short}:{summary}&quot;)
&#x27;</span>;

<span class="built_in">local</span> IFS=$<span class="string">&#x27;\n&#x27;</span>;

params=($(<span class="function"><span class="title">function</span></span> () {
  <span class="built_in">local</span> query=<span class="string">&quot;assignee=currentuser()%20AND%20status=%22In%20Progress%22&quot;</span>;
  <span class="built_in">local</span> params=<span class="string">&quot;jql=<span class="variable">${query}</span>&amp;fields=summary&quot;</span>

  curl -s -u <span class="string">&quot;<span class="variable">${email}</span>:<span class="variable">${token}</span>&quot;</span> \
  <span class="string">&quot;https://<span class="variable">${jira_host}</span>/rest/api/3/search\?<span class="variable">${params}</span>&quot;</span> \
    | python3 -c <span class="variable">$script</span>
}))

_describe <span class="string">&#x27;command&#x27;</span> params
</code></pre><p>Also important to note that in this script items of completion formatted using <code>item:description</code> pattern. This pattern of item is used by ZSH to format menu of completion with one line per item with description. It looks like that:</p><pre><code class="hljs language-sh">~ git fb EXMPL- <span class="comment"># &gt;TAB</span>
feature/EXMPL-1234 - This is description of ticket
feature/EXMPL-5678 - This is other description of other ticket
</code></pre>